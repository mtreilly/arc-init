// Copyright (c) 2025 Arc Engineering
// SPDX-License-Identifier: MIT

package cmd

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"

	"github.com/spf13/cobra"
)

type systemStatus struct {
	configCreated    bool
	configMerged     bool
	configUnchanged  bool
	templatesCreated int
	templatesSkipped int
	configPath       string
	templatesPath    string
	reason           string
}

func newSystemCmd() *cobra.Command {
	var (
		interactive    bool
		scaffold       bool
		force          bool
		templateSrcDir string
	)

	cmd := &cobra.Command{
		Use:   "system",
		Short: "Initialize global arc system configuration",
		Long: `Initialize global arc system configuration in ~/.config/arc/.

This command sets up your global arc configuration, including Discord integration
with message templates. Configuration is created in:

  ~/.config/arc/config.yaml      - Main configuration
  ~/.config/arc/discord.yaml     - Discord-specific settings
  ~/.config/arc/templates/       - Discord message templates

Idempotent: Running multiple times is safe. Existing files are not overwritten
unless --force is used.

Configuration search order:
  1. Project-local: .arc/config.yaml (searched up from current directory)
  2. Global: ~/.config/arc/config.yaml
  3. Environment variables (ARC_*)
  4. Default values`,
		Example: `  arc-init system --interactive
  arc-init system --scaffold
  arc-init system --interactive --template-src /path/to/templates
  arc-init system --force`,
		RunE: func(cmd *cobra.Command, args []string) error {
			if scaffold && interactive {
				return fmt.Errorf("cannot use both --scaffold and --interactive")
			}

			if !scaffold {
				interactive = true
			}

			var status systemStatus
			if interactive {
				if err := runSystemInteractive(force, templateSrcDir, &status); err != nil {
					return err
				}
			} else {
				if err := runSystemScaffold(force, templateSrcDir, &status); err != nil {
					return err
				}
			}

			reportSystemStatus(cmd, status)
			return nil
		},
	}

	cmd.Flags().BoolVarP(&interactive, "interactive", "i", false, "Interactive setup wizard (default)")
	cmd.Flags().BoolVar(&scaffold, "scaffold", false, "Create config scaffold only (user edits manually)")
	cmd.Flags().BoolVarP(&force, "force", "f", false, "Force overwrite existing config")
	cmd.Flags().StringVar(&templateSrcDir, "template-src", "", "Source directory for Discord templates")

	return cmd
}

func runSystemInteractive(force bool, templateSrcDir string, status *systemStatus) error {
	home, err := os.UserHomeDir()
	if err != nil {
		return fmt.Errorf("failed to get home directory: %w", err)
	}

	configDir := filepath.Join(home, ".config", "arc")
	templatesDir := filepath.Join(configDir, "templates")
	configFile := filepath.Join(configDir, "config.yaml")

	status.configPath = configFile
	status.templatesPath = templatesDir

	if err := os.MkdirAll(configDir, 0o755); err != nil {
		return fmt.Errorf("failed to create %s: %w", configDir, err)
	}

	existingConfig := parseExistingConfig(configFile)
	configExists := existingConfig != nil

	if configExists && !force {
		status.configUnchanged = true
		status.reason = "config already exists (use --force to update)"
		return nil
	}

	if templateSrcDir != "" {
		if err := setupTemplatesWithStatus(templatesDir, templateSrcDir, force, status); err != nil {
			return fmt.Errorf("failed to set up templates: %w", err)
		}
	}

	defaultResearchRoot := "~/arc-engineering/docs/research-external"
	defaultExternalRoot := "~/arc-engineering/external"
	if existingConfig != nil {
		if existingConfig.researchRoot != "" {
			defaultResearchRoot = existingConfig.researchRoot
		}
		if existingConfig.externalRoot != "" {
			defaultExternalRoot = existingConfig.externalRoot
		}
	}

	fmt.Println()
	if configExists {
		fmt.Println("=== Update Arc System Configuration ===")
		fmt.Println("Existing values shown in [brackets]. Press Enter to keep current value.")
	} else {
		fmt.Println("=== Arc System Configuration ===")
	}
	fmt.Println()

	scanner := bufio.NewScanner(os.Stdin)

	researchRoot := promptForValueWithDefault(scanner, "Research root", defaultResearchRoot)
	externalRoot := promptForValueWithDefault(scanner, "External repos root", defaultExternalRoot)

	config := fmt.Sprintf(`# Arc Configuration
# Generated by: arc init system
# Templates are located in: %s

research_root: "%s"
external_root: "%s"

concurrency:
  fetch: 4
  analyze: 2

ai:
  provider: anthropic
  default_model: claude-sonnet-4-5-20250929
  timeout: 30s
  max_tokens: 2000
  temperature: 0.7

claude:
  bin: claude
  model: claude-sonnet-4-5-20250929

discord:
  bot_token: ""
  webhooks: {}
  default_webhook: ""
`,
		templatesDir, researchRoot, externalRoot)

	if err := os.WriteFile(configFile, []byte(config), 0o644); err != nil {
		return fmt.Errorf("failed to write config: %w", err)
	}

	status.configCreated = true
	return nil
}

func runSystemScaffold(force bool, templateSrcDir string, status *systemStatus) error {
	home, err := os.UserHomeDir()
	if err != nil {
		return fmt.Errorf("failed to get home directory: %w", err)
	}

	configDir := filepath.Join(home, ".config", "arc")
	templatesDir := filepath.Join(configDir, "templates")
	configFile := filepath.Join(configDir, "config.yaml")

	status.configPath = configFile
	status.templatesPath = templatesDir

	if err := os.MkdirAll(configDir, 0o755); err != nil {
		return fmt.Errorf("failed to create %s: %w", configDir, err)
	}

	if _, err := os.Stat(configFile); err == nil && !force {
		status.configUnchanged = true
		status.reason = "scaffold already exists (use --force to regenerate)"
		return nil
	}

	if templateSrcDir != "" {
		if err := setupTemplatesWithStatus(templatesDir, templateSrcDir, force, status); err != nil {
			return fmt.Errorf("failed to set up templates: %w", err)
		}
	}

	scaffold := fmt.Sprintf(`# Arc Configuration Scaffold
# Generated by: arc init system
# Uncomment and customize the settings below.
# Templates are located in: %s

# research_root: ~/arc-engineering/docs/research-external
# external_root: ~/arc-engineering/external

# concurrency:
#   fetch: 4
#   analyze: 2

# ai:
#   provider: anthropic
#   default_model: claude-sonnet-4-5-20250929
#   timeout: 30s
#   max_tokens: 2000
#   temperature: 0.7

# claude:
#   bin: claude
#   model: claude-sonnet-4-5-20250929

# discord:
#   bot_token: ""
#   webhooks: {}
#   default_webhook: ""
`, templatesDir)

	if err := os.WriteFile(configFile, []byte(scaffold), 0o644); err != nil {
		return fmt.Errorf("failed to write config: %w", err)
	}

	status.configCreated = true
	return nil
}

func reportSystemStatus(cmd *cobra.Command, status systemStatus) {
	fmt.Fprintln(cmd.OutOrStdout())
	fmt.Fprintln(cmd.OutOrStdout(), "=== System Configuration Status ===")
	fmt.Fprintln(cmd.OutOrStdout())

	fmt.Fprintf(cmd.OutOrStdout(), "Config file: %s\n", status.configPath)
	fmt.Fprintf(cmd.OutOrStdout(), "Templates: %s\n\n", status.templatesPath)

	if status.configCreated {
		fmt.Fprintln(cmd.OutOrStdout(), "CONFIG - CREATED")
	} else if status.configUnchanged {
		fmt.Fprintf(cmd.OutOrStdout(), "CONFIG - UNCHANGED (%s)\n", status.reason)
		fmt.Fprintln(cmd.OutOrStdout())
		fmt.Fprintln(cmd.OutOrStdout(), "  Why: Config file already exists with settings")
		fmt.Fprintln(cmd.OutOrStdout(), "  To update: Edit config.yaml manually")
		fmt.Fprintln(cmd.OutOrStdout(), "  To replace: Run with --force flag")
	}

	if status.templatesCreated > 0 {
		fmt.Fprintln(cmd.OutOrStdout())
		fmt.Fprintf(cmd.OutOrStdout(), "TEMPLATES - %d/%d created\n", status.templatesCreated, status.templatesCreated+status.templatesSkipped)
	}
	if status.templatesSkipped > 0 {
		fmt.Fprintf(cmd.OutOrStdout(), "TEMPLATES - %d skipped (already exist)\n", status.templatesSkipped)
	}

	if status.configCreated {
		fmt.Fprintln(cmd.OutOrStdout())
		fmt.Fprintln(cmd.OutOrStdout(), "Next steps:")
		fmt.Fprintln(cmd.OutOrStdout(), "  - Edit ~/.config/arc/config.yaml to customize settings")
		fmt.Fprintln(cmd.OutOrStdout(), "  - Set ARC_* environment variables for overrides")
	}
}

func setupTemplatesWithStatus(destDir, srcDir string, force bool, status *systemStatus) error {
	if err := os.MkdirAll(destDir, 0o755); err != nil {
		return fmt.Errorf("failed to create templates directory: %w", err)
	}

	templateFiles := []string{
		"discord-update.json",
		"discord-alert.json",
		"discord-log.json",
	}

	for _, file := range templateFiles {
		srcFile := filepath.Join(srcDir, file)
		destFile := filepath.Join(destDir, file)

		if _, err := os.Stat(destFile); err == nil && !force {
			status.templatesSkipped++
			continue
		}

		if err := copyFile(srcFile, destFile); err != nil {
			continue // Skip missing files
		}
		status.templatesCreated++
	}

	return nil
}

func copyFile(src, dst string) error {
	srcFile, err := os.Open(src)
	if err != nil {
		return err
	}
	defer srcFile.Close()

	dstFile, err := os.Create(dst)
	if err != nil {
		return err
	}
	defer dstFile.Close()

	if _, err := io.Copy(dstFile, srcFile); err != nil {
		return err
	}

	srcInfo, err := os.Stat(src)
	if err != nil {
		return err
	}

	return os.Chmod(dst, srcInfo.Mode())
}

type existingSystemConfig struct {
	researchRoot string
	externalRoot string
}

func parseExistingConfig(configFile string) *existingSystemConfig {
	data, err := os.ReadFile(configFile)
	if err != nil {
		return nil
	}

	config := &existingSystemConfig{}
	lines := strings.Split(string(data), "\n")

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)
		if trimmed == "" || strings.HasPrefix(trimmed, "#") {
			continue
		}

		if strings.HasPrefix(trimmed, "research_root:") {
			config.researchRoot = extractValue(trimmed, "research_root:")
		} else if strings.HasPrefix(trimmed, "external_root:") {
			config.externalRoot = extractValue(trimmed, "external_root:")
		}
	}

	return config
}

func extractValue(line, prefix string) string {
	value := strings.TrimSpace(strings.TrimPrefix(line, prefix))
	value = strings.Trim(value, "\"'")
	return value
}

func promptForValueWithDefault(scanner *bufio.Scanner, prompt, defaultValue string) string {
	fmt.Printf("%s [%s]: ", prompt, defaultValue)
	scanner.Scan()
	value := strings.TrimSpace(scanner.Text())

	if value == "" {
		return defaultValue
	}
	return value
}
