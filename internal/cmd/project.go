// Copyright (c) 2025 Arc Engineering
// SPDX-License-Identifier: MIT

package cmd

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/spf13/cobra"
	"gopkg.in/yaml.v3"
)

type projectStatus struct {
	created        bool
	merged         bool
	unchanged      bool
	reason         string
	addedKeys      []string
	gitignoreAdded bool
	configPath     string
}

func newProjectCmd() *cobra.Command {
	var (
		interactive bool
		force       bool
		gitignore   bool
		scaffold    bool
	)

	cmd := &cobra.Command{
		Use:   "project",
		Short: "Initialize project-local arc configuration",
		Long: `Initialize a project-local arc configuration in .arc/config.yaml.

This command helps you set up project-specific configuration that will override
global settings from ~/.config/arc/config.yaml. Configuration is searched in order:

  1. .arc/config.yaml (project-local, searched up from current directory)
  2. ~/.config/arc/config.yaml (global)
  3. Environment variables (ARC_*)
  4. Default values

Idempotent: Running multiple times is safe. Existing configs are not overwritten.
Use --force to replace entirely.

The .arc/ directory can be committed to git for team collaboration or added
to .gitignore for project-local settings.`,
		Example: `  arc-init project --interactive
  arc-init project --scaffold
  arc-init project --scaffold --gitignore
  arc-init project --force`,
		RunE: func(cmd *cobra.Command, args []string) error {
			if scaffold && interactive {
				return fmt.Errorf("cannot use both --scaffold and --interactive")
			}

			if !scaffold {
				interactive = true
			}

			var status projectStatus
			if interactive {
				if err := runInteractiveProject(force, &status); err != nil {
					return err
				}
			} else {
				if err := runScaffoldProject(gitignore, force, &status); err != nil {
					return err
				}
			}

			reportProjectStatus(cmd, status)
			return nil
		},
	}

	cmd.Flags().BoolVarP(&interactive, "interactive", "i", false, "Interactive setup wizard (default)")
	cmd.Flags().BoolVar(&scaffold, "scaffold", false, "Create config scaffold only (user edits manually)")
	cmd.Flags().BoolVarP(&gitignore, "gitignore", "g", false, "Add .arc/ to .gitignore")
	cmd.Flags().BoolVarP(&force, "force", "f", false, "Force overwrite existing config")

	return cmd
}

func runInteractiveProject(force bool, status *projectStatus) error {
	arcDir := ".arc"
	configFile := filepath.Join(arcDir, "config.yaml")
	status.configPath = configFile

	var existingConfig map[string]interface{}
	fileExists := false

	if _, err := os.Stat(configFile); err == nil {
		fileExists = true
		if !force {
			data, err := os.ReadFile(configFile)
			if err != nil {
				return err
			}
			if err := yaml.Unmarshal(data, &existingConfig); err != nil {
				return err
			}
			if hasAllProjectKeys(existingConfig) {
				status.unchanged = true
				status.reason = "config already complete with all settings"
				return nil
			}
		}
	}

	if err := os.MkdirAll(arcDir, 0o755); err != nil {
		return fmt.Errorf("failed to create %s: %w", arcDir, err)
	}

	fmt.Println()
	fmt.Println("=== Arc Project Configuration ===")
	fmt.Println()

	scanner := bufio.NewScanner(os.Stdin)

	researchRoot := getOrPrompt(scanner, existingConfig, "research_root",
		"Research root", "~/arc-engineering/docs/research-external")
	if researchRoot == "" {
		researchRoot = "~/arc-engineering/docs/research-external"
	}

	externalRoot := getOrPrompt(scanner, existingConfig, "external_root",
		"External repos root", "~/arc-engineering/external")
	if externalRoot == "" {
		externalRoot = "~/arc-engineering/external"
	}

	provider := getOrPrompt(scanner, existingConfig, "ai.provider",
		"AI provider", "anthropic")
	if provider == "" {
		provider = "anthropic"
	}

	model := getOrPrompt(scanner, existingConfig, "ai.default_model",
		"AI default model", "claude-sonnet-4-5-20250929")
	if model == "" {
		model = "claude-sonnet-4-5-20250929"
	}

	config := fmt.Sprintf(`# Arc Project Configuration
# Generated by: arc init project

research_root: %s
external_root: %s

concurrency:
  fetch: 4
  analyze: 2

ai:
  provider: %s
  default_model: %s
  timeout: 30s
  max_tokens: 2000
  temperature: 0.7

claude:
  bin: claude
  model: claude-sonnet-4-5-20250929

discord:
  bot_token: ""
  webhooks: {}
  default_webhook: ""
`,
		researchRoot, externalRoot, provider, model)

	if !fileExists {
		status.created = true
		status.addedKeys = []string{"research_root", "external_root", "concurrency", "ai", "claude", "discord"}
	} else {
		status.merged = true
		status.addedKeys = []string{"research_root", "external_root", "concurrency", "ai", "claude", "discord"}
	}

	if err := os.WriteFile(configFile, []byte(config), 0o644); err != nil {
		return fmt.Errorf("failed to write config: %w", err)
	}

	addToGitignore := promptForConfirmation(scanner, "Add .arc/ to .gitignore?", true)
	if addToGitignore {
		if err := addToGitignoreFile(); err != nil {
			return fmt.Errorf("failed to update .gitignore: %w", err)
		}
		status.gitignoreAdded = true
	}

	return nil
}

func runScaffoldProject(gitignore, force bool, status *projectStatus) error {
	arcDir := ".arc"
	configFile := filepath.Join(arcDir, "config.yaml")
	status.configPath = configFile

	if _, err := os.Stat(configFile); err == nil && !force {
		status.unchanged = true
		status.reason = "scaffold already exists (use --force to regenerate)"
		return nil
	}

	status.created = true

	if err := os.MkdirAll(arcDir, 0o755); err != nil {
		return fmt.Errorf("failed to create %s: %w", arcDir, err)
	}

	scaffold := `# Arc Project Configuration Scaffold
# Uncomment and customize the settings below to override global defaults.
# See ~/.config/arc/config.yaml for global configuration.

# research_root: ~/arc-engineering/docs/research-external
# external_root: ~/arc-engineering/external

# concurrency:
#   fetch: 4
#   analyze: 2

# ai:
#   provider: anthropic
#   default_model: claude-sonnet-4-5-20250929
#   timeout: 30s
#   max_tokens: 2000
#   temperature: 0.7

# claude:
#   bin: claude
#   model: claude-sonnet-4-5-20250929

# discord:
#   bot_token: ""
#   webhooks: {}
#   default_webhook: ""
`

	if err := os.WriteFile(configFile, []byte(scaffold), 0o644); err != nil {
		return fmt.Errorf("failed to write config: %w", err)
	}

	if gitignore {
		if err := addToGitignoreFile(); err != nil {
			return fmt.Errorf("failed to update .gitignore: %w", err)
		}
		status.gitignoreAdded = true
	}

	return nil
}

func reportProjectStatus(cmd *cobra.Command, status projectStatus) {
	fmt.Fprintln(cmd.OutOrStdout())
	fmt.Fprintln(cmd.OutOrStdout(), "=== Project Configuration Status ===")
	fmt.Fprintln(cmd.OutOrStdout())

	fmt.Fprintf(cmd.OutOrStdout(), "Config file: %s\n\n", status.configPath)

	if status.created {
		fmt.Fprintln(cmd.OutOrStdout(), "CREATED - New project configuration file")
	} else if status.merged {
		fmt.Fprintln(cmd.OutOrStdout(), "MERGED - Updated with new settings")
		if len(status.addedKeys) > 0 {
			fmt.Fprintln(cmd.OutOrStdout(), "  Added keys:")
			for _, key := range status.addedKeys {
				fmt.Fprintf(cmd.OutOrStdout(), "    - %s\n", key)
			}
		}
	} else if status.unchanged {
		fmt.Fprintf(cmd.OutOrStdout(), "UNCHANGED - %s\n", status.reason)
		fmt.Fprintln(cmd.OutOrStdout())
		fmt.Fprintln(cmd.OutOrStdout(), "  Why: Config file already exists with all settings")
		fmt.Fprintln(cmd.OutOrStdout(), "  To update: Edit .arc/config.yaml manually")
		fmt.Fprintln(cmd.OutOrStdout(), "  To replace: Run with --force flag")
	}

	if status.gitignoreAdded {
		fmt.Fprintln(cmd.OutOrStdout())
		fmt.Fprintln(cmd.OutOrStdout(), ".gitignore - Added .arc/ entry")
	}

	if status.created || status.merged {
		fmt.Fprintln(cmd.OutOrStdout())
		fmt.Fprintln(cmd.OutOrStdout(), "Next steps:")
		fmt.Fprintln(cmd.OutOrStdout(), "  - Edit .arc/config.yaml to customize settings")
		fmt.Fprintln(cmd.OutOrStdout(), "  - Commit to git for team use, or add to .gitignore for local-only")
	}
}

func getOrPrompt(scanner *bufio.Scanner, existing map[string]interface{}, key, prompt, defaultVal string) string {
	if existing != nil {
		if val, ok := existing[key]; ok {
			if str, ok := val.(string); ok && str != "" {
				fmt.Printf("%s [%s (existing)]: ", prompt, str)
				if scanner.Scan() {
					input := strings.TrimSpace(scanner.Text())
					if input != "" {
						return input
					}
					return str
				}
				return str
			}
		}
	}

	return promptForValue(scanner, prompt, defaultVal)
}

func hasAllProjectKeys(config map[string]interface{}) bool {
	if config == nil {
		return false
	}

	requiredKeys := []string{"research_root", "external_root", "concurrency", "ai"}
	for _, key := range requiredKeys {
		if _, ok := config[key]; !ok {
			return false
		}
	}
	return true
}

func promptForValue(scanner *bufio.Scanner, prompt, defaultVal string) string {
	fmt.Printf("%s (%s): ", prompt, defaultVal)
	if scanner.Scan() {
		val := strings.TrimSpace(scanner.Text())
		if val != "" {
			return val
		}
	}
	return defaultVal
}

func promptForConfirmation(scanner *bufio.Scanner, prompt string, defaultVal bool) bool {
	defaultStr := "Y/n"
	if !defaultVal {
		defaultStr = "y/N"
	}
	fmt.Printf("%s (%s): ", prompt, defaultStr)

	if scanner.Scan() {
		response := strings.TrimSpace(strings.ToLower(scanner.Text()))
		if response == "y" {
			return true
		}
		if response == "n" {
			return false
		}
	}
	return defaultVal
}

func addToGitignoreFile() error {
	gitignorePath := ".gitignore"
	content := ""

	if data, err := os.ReadFile(gitignorePath); err == nil {
		content = string(data)
	}

	if strings.Contains(content, ".arc/") {
		return nil
	}

	entry := ".arc/\n"
	if !strings.HasSuffix(content, "\n") && content != "" {
		entry = "\n" + entry
	}

	return os.WriteFile(gitignorePath, []byte(content+entry), 0o644)
}
